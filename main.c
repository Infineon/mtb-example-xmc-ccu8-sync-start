/******************************************************************************
* File Name:   main.c
*
* Description: This is the source code for the XMC MCU: CCU8 Timer synchronous
*              start Example for ModusToolbox.
*
* Related Document: See README.md
*
******************************************************************************
*
* Copyright (c) 2015-2021, Infineon Technologies AG
* All rights reserved.                        
*                                             
* Boost Software License - Version 1.0 - August 17th, 2003
* 
* Permission is hereby granted, free of charge, to any person or organization
* obtaining a copy of the software and accompanying documentation covered by
* this license (the "Software") to use, reproduce, display, distribute,
* execute, and transmit the Software, and to prepare derivative works of the
* Software, and to permit third-parties to whom the Software is furnished to
* do so, all subject to the following:
* 
* The copyright notices in the Software and this entire statement, including
* the above license grant, this restriction and the following disclaimer,
* must be included in all copies of the Software, in whole or in part, and
* all derivative works of the Software, unless such copies or derivative
* works are solely in the form of machine-executable object code generated by
* a source language processor.
* 
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
* SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
* FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
* DEALINGS IN THE SOFTWARE.
*                                                                              
*****************************************************************************/

#include "cybsp.h"
#include "cy_utils.h"
#include "xmc_ccu8.h"
#include "xmc_eru.h"

/*******************************************************************************
* Macros
*******************************************************************************/
/*Definition of macros for XMC14x Boot kit*/
#ifdef TARGET_KIT_XMC14_BOOT_001
#define EXTERNAL_INPUT_SIGNAL_PIN             ERU0_ETL1_INPUTA_P2_5
#define ERU_GROUP_ETL_CHANNEL                 ERU0_ETL1
#define ERU_GROUP_OGU_CHANNEL                 ERU0_OGU0
#define INTERRUPT_PRIORITY_NODE_ID            IRQ3_IRQn
#define INTERRUPT_EVENT_PRIORITY              (3U)
#define ERU_EXTERNAL_EVENT_HANDLER            IRQ_Hdlr_3

#define PERIOD_MATCH_COUNT                    (46874U)
#define PRESCALER_INITVAL                     (11U)

#define SLICE_PTR                             CCU80_CC81
#define MODULE_PTR                            CCU80
#define TIMER_0_PERIOD_MATCH_EVENT_PRIORITY   3
#define TIMER_0_PERIOD_MATCH_EVENT_HANDLER    IRQ_Hdlr_1
#define XMC_CCU8_SERVICE_REQUEST_ID           XMC_CCU8_SLICE_SR_ID_0
#define TIMER_0_PERIOD_MATCH_EVENT_IRQN       IRQ1_IRQn

#define SLICE_PTR1                            CCU81_CC81
#define MODULE_PTR1                           CCU81
#define TIMER_1_PERIOD_MATCH_EVENT_PRIORITY   3
#define TIMER_1_PERIOD_MATCH_EVENT_HANDLER    IRQ_Hdlr_25
#define XMC_CCU81_SERVICE_REQUEST_ID          XMC_CCU8_SLICE_SR_ID_0
#define TIMER_1_PERIOD_MATCH_EVENT_IRQN       IRQ25_IRQn
#endif

/*Definition of macros for XMC47x Relax kit*/
#ifdef TARGET_KIT_XMC47_RELAX_V1
#define EXTERNAL_INPUT_SIGNAL_PIN             ERU1_ETL1_INPUTA_P1_15
#define ERU_GROUP_ETL_CHANNEL                 ERU1_ETL1
#define ERU_GROUP_OGU_CHANNEL                 ERU1_OGU0
#define INTERRUPT_PRIORITY_NODE_ID            ERU1_0_IRQn
#define INTERRUPT_EVENT_PRIORITY              (63U)
#define ERU_EXTERNAL_EVENT_HANDLER            IRQ_Hdlr_5

#define PERIOD_MATCH_COUNT                    (35155U)
#define PRESCALER_INITVAL                     (12U)

#define SLICE_PTR                             CCU80_CC81
#define MODULE_PTR                            CCU80
#define TIMER_0_PERIOD_MATCH_EVENT_PRIORITY   61
#define TIMER_0_PERIOD_MATCH_EVENT_HANDLER    IRQ_Hdlr_61
#define XMC_CCU8_SERVICE_REQUEST_ID           XMC_CCU8_SLICE_SR_ID_1
#define TIMER_0_PERIOD_MATCH_EVENT_IRQN       CCU80_1_IRQn

#define SLICE_PTR1                            CCU81_CC81
#define MODULE_PTR1                           CCU81
#define TIMER_1_PERIOD_MATCH_EVENT_PRIORITY   61
#define TIMER_1_PERIOD_MATCH_EVENT_HANDLER    IRQ_Hdlr_65
#define XMC_CCU8_SERVICE_REQUEST_ID           XMC_CCU8_SLICE_SR_ID_1
#define TIMER_1_PERIOD_MATCH_EVENT_IRQN       CCU81_1_IRQn
#endif

#define SLICE_NUMBER                          (1U)
#define MODULE_NUMBER                         (1U)


/*******************************************************************************
* Global Variables
*******************************************************************************/
static volatile bool timer0_interrupt_flag = false;
static volatile bool timer1_interrupt_flag = false;

/*******************************************************************************
* Data Structure
*******************************************************************************/
/*Initialization data of a CCU8 Slice*/
XMC_CCU8_SLICE_COMPARE_CONFIG_t g_timer_object =
{
    .timer_mode          = XMC_CCU8_SLICE_TIMER_COUNT_MODE_EA,       /*Select Edge aligned or Centre Aligned*/
    .monoshot            = false,                                    /*Repetitive mode: continuous mode of operation*/
    .shadow_xfer_clear   = false,                                    /*Select PR and CR shadow xfer happen when timer is cleared*/
    .dither_timer_period = false,                                    /*Select for the period of the timer dither*/
    .dither_duty_cycle   = false,                                    /*Select for the compare match of the timer dither*/
    .prescaler_mode      = XMC_CCU8_SLICE_PRESCALER_MODE_NORMAL,     /*Normal or floating prescaler mode selection*/
    .mcm_ch1_enable      = false,                                    /*Select Multi-Channel mode for compare channel 1 enable*/
    .mcm_ch2_enable      = false,                                    /*Select Multi-Channel mode for compare channel 2 enable*/
    .slice_status        = XMC_CCU8_SLICE_STATUS_CHANNEL_1,          /*Selection for which of the two channels drives the slice status output*/
    .asymmetric_pwm      = false,                                    /*Select if the PWM be a function of the 2 compare channels rather than period value*/
    .prescaler_initval   = PRESCALER_INITVAL,                        /*Prescaler divider value*/
    .float_limit         = 0U,                                       /*The max value which the prescaler divider can increment to*/
    .dither_limit        = 0U,                                       /*The value that determines the spreading of dithering*/
    .timer_concatenation = false                                     /*Enables the concatenation of the timer*/
};

/*Structure for initializing ERUx_ETLy module*/
XMC_ERU_ETL_CONFIG_t button_event_generator_config =
{
    .input                  = EXTERNAL_INPUT_SIGNAL_PIN,            /*Configures input signal for Event request source unit */
    .source                 = XMC_ERU_ETL_SOURCE_A,                 /*Input path combination along with polarity for event generation.*/
    .edge_detection         = XMC_ERU_ETL_EDGE_DETECTION_FALLING,   /*Configure the event trigger edge(FE, RE)*/
    .status_flag_mode       = XMC_ERU_ETL_STATUS_FLAG_MODE_HWCTRL,  /*Enables the status flag for sticky mode or non sticky mode*/
    .enable_output_trigger  = true,                                 /*Enables the generation of trigger pulse(PE), for the configured edge detection*/
    .output_trigger_channel = XMC_ERU_ETL_OUTPUT_TRIGGER_CHANNEL0   /*Output channel select(OCS) for ETLx output trigger pulse*/
};

/*Structure for initializing ERUx_OGUy module.*/
XMC_ERU_OGU_CONFIG_t button_event_detection_config =
{
    .service_request        = XMC_ERU_OGU_SERVICE_REQUEST_ON_TRIGGER /*Gating(GP) on service request generation for pattern detection result*/
};

/*******************************************************************************
* Function Name: TIMER_0_PERIOD_MATCH_EVENT_HANDLER
********************************************************************************
* Summary:
* This is the interrupt handler function for the CCU8 timer period match interrupt.
*
* Parameters:
*  void
*
* Return:
*  void
*
*******************************************************************************/
void TIMER_0_PERIOD_MATCH_EVENT_HANDLER(void)
{
    timer0_interrupt_flag = true;
}

/*******************************************************************************
* Function Name: TIMER_1_PERIOD_MATCH_EVENT_HANDLER
********************************************************************************
* Summary:
* This is the interrupt handler function for the CCU81 timer period match interrupt.
*
* Parameters:
*  void
*
* Return:
*  void
*
*******************************************************************************/
void TIMER_1_PERIOD_MATCH_EVENT_HANDLER(void)
{
    timer1_interrupt_flag = true;
}

/*******************************************************************************
* Function Name: timer0_init
********************************************************************************
* Summary:
* This is the function which initializes all the parameters needed for CCU80 timer.
*
* Parameters:
*  void
*
* Return:
*  void
*
*******************************************************************************/
void timer0_init(void)
{
    /*Set CCU8 Module clock*/
    XMC_CCU8_SetModuleClock(MODULE_PTR, XMC_CCU8_CLOCK_SCU);

    /*Set CCU8 Module Init*/
    XMC_CCU8_Init(MODULE_PTR, XMC_CCU8_SLICE_MCMS_ACTION_TRANSFER_PR_CR);

    /*Enable the CCU8 Slice Clock*/
    XMC_CCU8_EnableClock(MODULE_PTR, SLICE_NUMBER);

    /*Start the prescaler and restore clocks to slices*/
    XMC_CCU8_StartPrescaler(MODULE_PTR);

    /*Initialize the CCU8 Slice*/
    XMC_CCU8_SLICE_CompareInit(SLICE_PTR, &g_timer_object);

    /*Program a value into Period Match register*/
    XMC_CCU8_SLICE_SetTimerPeriodMatch(SLICE_PTR, PERIOD_MATCH_COUNT);

    /*Enable shadow transfer*/
    XMC_CCU8_EnableShadowTransfer(MODULE_PTR, XMC_CCU8_SHADOW_TRANSFER_SLICE_1);

    /*Enable Period Match event*/
    XMC_CCU8_SLICE_EnableEvent(SLICE_PTR, XMC_CCU8_SLICE_IRQ_ID_PERIOD_MATCH);

    /*Connect Period Match event to Service Request lines -SRx*/
    XMC_CCU8_SLICE_SetInterruptNode(SLICE_PTR, XMC_CCU8_SLICE_IRQ_ID_PERIOD_MATCH, XMC_CCU8_SERVICE_REQUEST_ID);

    /*Clears IDLE mode for the slice*/
    XMC_CCU8_EnableClock(MODULE_PTR, SLICE_NUMBER);
}

/*******************************************************************************
* Function Name: timer1_init
********************************************************************************
* Summary:
* This is the function which initializes all the parameters needed for CCU81 timer.
*
* Parameters:
*  void
*
* Return:
*  void
*
*******************************************************************************/
void timer1_init(void)
{
    /*Set CCU8 Module clock*/
    XMC_CCU8_SetModuleClock(MODULE_PTR1, XMC_CCU8_CLOCK_SCU);

    /*Set CCU8 Module Init*/
    XMC_CCU8_Init(MODULE_PTR1, XMC_CCU8_SLICE_MCMS_ACTION_TRANSFER_PR_CR);

    /*Enable the CCU8 Slice Clock*/
    XMC_CCU8_EnableClock(MODULE_PTR1, SLICE_NUMBER);

    /*Start the prescaler and restore clocks to slices*/
    XMC_CCU8_StartPrescaler(MODULE_PTR1);

    /*Initialize the CCU8 Slice*/
    XMC_CCU8_SLICE_CompareInit(SLICE_PTR1, &g_timer_object);

    /*Program a value into Period Match register*/
    XMC_CCU8_SLICE_SetTimerPeriodMatch(SLICE_PTR1, PERIOD_MATCH_COUNT);

    /*Enable shadow transfer*/
    XMC_CCU8_EnableShadowTransfer(MODULE_PTR1, XMC_CCU8_SHADOW_TRANSFER_SLICE_1);

    /*Enable Period Match event*/
    XMC_CCU8_SLICE_EnableEvent(SLICE_PTR1, XMC_CCU8_SLICE_IRQ_ID_PERIOD_MATCH);

    /*Connect Period Match event to Service Request lines -SRx*/
    XMC_CCU8_SLICE_SetInterruptNode(SLICE_PTR1, XMC_CCU8_SLICE_IRQ_ID_PERIOD_MATCH, XMC_CCU8_SERVICE_REQUEST_ID);

    /*Clears IDLE mode for the slice*/
    XMC_CCU8_EnableClock(MODULE_PTR1, SLICE_NUMBER);
}

/*******************************************************************************
* Function Name: configure_eru
********************************************************************************
* Summary:
* This is the function which initializes all the parameters needed for the ERU.
*
* Parameters:
*  void
*
* Return:
*  void
*
*******************************************************************************/
void configure_eru(void)
{
    /*Initializes the selected ERU_ETLx channel with the configuration structure*/
    XMC_ERU_ETL_Init(ERU_GROUP_ETL_CHANNEL, &button_event_generator_config);

    /*Initializes the selected ERU_OGUy channel with the configuration structure*/
    XMC_ERU_OGU_Init(ERU_GROUP_OGU_CHANNEL, &button_event_detection_config);

    #ifdef TARGET_KIT_XMC14_BOOT_001
    /*Set Priority for IRQ*/
    NVIC_SetPriority(INTERRUPT_PRIORITY_NODE_ID, INTERRUPT_EVENT_PRIORITY);
    #endif

    #ifdef TARGET_KIT_XMC47_RELAX_V1
    /*Set Priority for IRQ*/
    NVIC_SetPriority(INTERRUPT_PRIORITY_NODE_ID, NVIC_EncodePriority(NVIC_GetPriorityGrouping(), INTERRUPT_EVENT_PRIORITY, 0));
    #endif

    /*Enable the Interrupt*/
    NVIC_EnableIRQ(INTERRUPT_PRIORITY_NODE_ID);
}

/*******************************************************************************
* Function Name: configure_timer0_interrupt
********************************************************************************
* Summary:
* This is the function which configures the parameters needed for the interrupt that
* will be generated by the period match of the CCU80 timer.
*
* Parameters:
*  void
*
* Return:
*  void
*
*******************************************************************************/
void configure_timer0_interrupt(void)
{
#ifdef TARGET_KIT_XMC14_BOOT_001
    /*Interrupt Multiplexer configuration*/
    XMC_SCU_SetInterruptControl(TIMER_0_PERIOD_MATCH_EVENT_IRQN, XMC_SCU_IRQCTRL_CCU80_SR0_IRQ1);
    /*Set priority*/
    NVIC_SetPriority(TIMER_0_PERIOD_MATCH_EVENT_IRQN, TIMER_0_PERIOD_MATCH_EVENT_PRIORITY);
#endif

#ifdef TARGET_KIT_XMC47_RELAX_V1
    /*Set Interrupt priority by encoding the priority in the required groups*/
    NVIC_SetPriority(TIMER_0_PERIOD_MATCH_EVENT_IRQN, NVIC_EncodePriority(NVIC_GetPriorityGrouping(), TIMER_0_PERIOD_MATCH_EVENT_PRIORITY, 0));
#endif

    /*Enable IRQ*/
    NVIC_EnableIRQ(TIMER_0_PERIOD_MATCH_EVENT_IRQN);
}

/*******************************************************************************
* Function Name: configure_timer1_interrupt
********************************************************************************
* Summary:
* This is the function which configures the parameters needed for the interrupt that
* will be generated by the period match of the CCU81 timer.
*
* Parameters:
*  void
*
* Return:
*  void
*
*******************************************************************************/

void configure_timer1_interrupt(void)
{
#ifdef TARGET_KIT_XMC14_BOOT_001
    /*Interrupt Multiplexer configuration*/
    XMC_SCU_SetInterruptControl(TIMER_1_PERIOD_MATCH_EVENT_IRQN, XMC_SCU_IRQCTRL_CCU81_SR0_IRQ25);
    /*Set priority*/
    NVIC_SetPriority(TIMER_1_PERIOD_MATCH_EVENT_IRQN, TIMER_1_PERIOD_MATCH_EVENT_PRIORITY);
#endif

#ifdef TARGET_KIT_XMC47_RELAX_V1
    /*Set Interrupt priority by encoding the priority in the required groups*/
    NVIC_SetPriority(TIMER_1_PERIOD_MATCH_EVENT_IRQN, NVIC_EncodePriority(NVIC_GetPriorityGrouping(), TIMER_1_PERIOD_MATCH_EVENT_PRIORITY, 0));
#endif

    /*Enable IRQ*/
    NVIC_EnableIRQ(TIMER_1_PERIOD_MATCH_EVENT_IRQN);
}

/*******************************************************************************
* Function Name: ERU_EXTERNAL_EVENT_HANDLER
********************************************************************************
* Summary:
* This is the interrupt handler function for the ERU external interrupt which starts
* the CCU8 timers and configures their respective interrupts for the toggling of LED's
*
* Parameters:
*  void
*
* Return:
*  void
*
*******************************************************************************/
void ERU_EXTERNAL_EVENT_HANDLER(void)
{
    /*Starts the particular slice of the Timer used*/
    XMC_CCU8_SLICE_StartTimer(SLICE_PTR);
    XMC_CCU8_SLICE_StartTimer(SLICE_PTR1);

    /*Configures the timers to receive the interrupts*/
    configure_timer0_interrupt();
    configure_timer1_interrupt();
}

/*******************************************************************************
* Function Name: main
********************************************************************************
* Summary:
* This is the main function.It sets up a CCU8 timers to period match interrupt.
* The main while loop checks for the elapsed time due to CCU8 timers period match
* event and toggles 2 LEDs at approximately 0.5Hz.
*
* Parameters:
*  void
*
* Return:
*  int
*
*******************************************************************************/
int main(void)
{
    cy_rslt_t result;

    /*Initialize the device and board peripherals*/
    result = cybsp_init();
    if (result != CY_RSLT_SUCCESS)
    {
        CY_ASSERT(0);
    }
#ifdef TARGET_KIT_XMC47_RELAX_V1
    /*The USER leds on the 4700 kit are active high. The User LED2 is turned on here */
    XMC_GPIO_SetOutputHigh(CYBSP_USER_LED2_PORT, CYBSP_USER_LED2_PIN);
#endif
#ifdef TARGET_KIT_XMC14_BOOT_001
    /*The USER leds on the 1400 kit are active low. The User LED2 is turned on here */
    XMC_GPIO_SetOutputLow(CYBSP_USER_LED2_PORT, CYBSP_USER_LED2_PIN);
#endif
    /*Initializes the CCU8 timer 0 */
    timer0_init();

    /*Initializes the CCU8 timer 1 */
    timer1_init();

    /*Configures the Event Register Unit*/
    configure_eru();

    /*Infinite loop*/
    while (1)
    {
        /*Check if timer elapsed (interrupt fired) and toggle the LED*/
        if (timer0_interrupt_flag)
        {
            /*Clear the timer 0 interrupt flag */
            timer0_interrupt_flag = false;
            /* Toggle the USER LED state */
            XMC_GPIO_ToggleOutput(CYBSP_USER_LED_PORT, CYBSP_USER_LED_PIN);
        }
        if (timer1_interrupt_flag)
        {
            /*Clear the timer 1 interrupt flag */
            timer1_interrupt_flag = false;
            /* Toggle the USER LED state */
            XMC_GPIO_ToggleOutput(CYBSP_USER_LED2_PORT, CYBSP_USER_LED2_PIN);
        }

    }
}

/* [] END OF FILE */
